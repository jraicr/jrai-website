---
import "@/styles/global.css";
import { ViewTransitions } from "astro:transitions";
import { getLangFromUrl } from "@/i18n/utils";

const lang = getLangFromUrl(Astro.url);

interface Props {
    title: string;
}

const { title } = Astro.props;
---

<!doctype html>
<html lang={lang}>
    <head>
        <meta charset="UTF-8" />
        <meta name="description" content="J. Rai es un desarrollador full-stack y de videojuegos que construye experiencias multimedia interactivas." />
        <meta name="viewport" content="width=device-width" />

        <!-- og  -->
        <meta property="og:locale" content="es_ES">
        <meta property="og:locale:alternate" content="en_US" />
        <meta property="og:site_name" content="J. Rai">
        <meta property="og:type" content="website">
        <meta property="twitter:card" content="summary_large_image">
        <meta property="twitter:creator" content="@jraidev">
        <meta property="twitter:site" content="@jraidev">
        <meta property="og:title" content="J. Rai">
        <meta property="og:description" content="J. Rai es un desarrollador full-stack y de videojuegos que construye experiencias multimedia interactivas.">
        <meta property="og:url" content="https://jrai.dev/">
        <meta property="og:image" content="https://jrai.dev/og.png">
        <meta property="twitter:title" content="J. Rai">
        <meta property="twitter:description" content="J. Rai es un desarrollador full-stack y de videojuegos que construye experiencias multimedia interactivas.">
        <meta property="twitter:url" content="https://jrai.dev/">
        <meta property="twitter:image" content="https://jrai.dev/og.png">

        <!-- CSS Fonts -->
        <link rel="stylesheet" href="/styles/fonts.css" media="print" onload="this.media = 'all'" />

        <!-- Favicon -->
        <link rel="icon" href="/icons/favicon.ico" />
        <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png" />
        
        <link rel="manifest" href="site.webmanifest" />
        <meta name="theme-color" content="#170e25" />
        <meta name="generator" content={Astro.generator} />

        <title>{title}</title>
        <ViewTransitions />
    </head>
    <body>
        <slot />
    </body>
</html>
<script>
    let gradientContainer = document.querySelector<HTMLElement>(
        ".gradient-container",
    );
    let currentGradientPosition = { x: 0, y: 0 };
    let targetGradientPosition = { x: 0, y: 0 };
    let animationFrameId: number | null = null;
    let isGradientMoving = false;

    startGradientEffect();

    // Añade un controlador de eventos para reiniciar el efecto del gradiente después de un intercambio de Astro
    document.addEventListener("astro:after-swap", awakeGradientEffect);

    /**
     * Despierta el efecto del gradiente después de un intercambio de Astro.
     */
    function awakeGradientEffect() {
        gradientContainer = document.querySelector(".gradient-container");
        startGradientEffect();
    }

    /**
     * Inicia el efecto del gradiente.
     */
    function startGradientEffect() {
        let currentScreenWidth = window.innerWidth;

        if (currentScreenWidth >= 1024) {
            onMouseMovementUpdateTargetGradientPos();
            onScrollCenterGradient();
            updateCurrentGradientPosition();
        }
    }

    /**
     * Actualiza la posición objetivo del gradiente.
     *
     * @param {number} x - La coordenada x de la posición objetivo.
     * @param {number} y - La coordenada y de la posición objetivo.
     */
    function updateTargetGradientPos(x: number, y: number) {
        targetGradientPosition.x = x;
        targetGradientPosition.y = y;
        restartAnimation();
    }

    /**
     * Añade un controlador de eventos para actualizar la posición objetivo del
     * gradiente a la posición del puntero del ratón.
     */
    function onMouseMovementUpdateTargetGradientPos() {
        gradientContainer?.addEventListener(
            "mousemove",
            (e: MouseEvent) => {
                updateTargetGradientPos(e.pageX, e.pageY);
            },
        );
    }

    /**
     * Añade un controlador de eventos para actualizar la posición objetivo del gradiente al centro
     * de la ventana (con un offset hacia el contenido) visible cuando se hace scroll.
     */
    function onScrollCenterGradient() {
        window.addEventListener("scroll", (e) => {
            let offsetX = 250;
            let targetX = window.scrollX + window.innerWidth / 2 + offsetX;
            let targetY = window.scrollY + window.innerHeight / 2;

            updateTargetGradientPos(targetX, targetY);
        });
    }

    /**
     * Actualiza la posición actual del gradiente.
     */
    function updateCurrentGradientPosition() {
        let dx = Math.abs(
            currentGradientPosition.x - targetGradientPosition.x,
        );
        let dy = Math.abs(
            currentGradientPosition.y - targetGradientPosition.y,
        );
        let distance = Math.sqrt(dx * dx + dy * dy);

        let lerpFactor = 0.07; // Determina velocidad de movimiento del gradiente

        isGradientMoving = distance > 1;

        // console.debug(`Is gradient moving?: ${isGradientMoving}`, currentGradientPosition);

        if (isGradientMoving) {
            currentGradientPosition = interpolate(
                currentGradientPosition,
                targetGradientPosition,
                lerpFactor,
            );

            if (gradientContainer) {
                gradientContainer.style.background = `radial-gradient(600px circle at ${currentGradientPosition.x}px ${currentGradientPosition.y}px, hsla(274, 100%, 35%, 0.25), transparent 80%)`;
            }

            animationFrameId = requestAnimationFrame(
                updateCurrentGradientPosition,
            );
        } else if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
        }
    }

    /**
     * Reinicia la animación si el gradiente no se está moviendo y no hay ningún cuadro de animación solicitado.
     */
    function restartAnimation() {
        if (!isGradientMoving && !animationFrameId) {
            updateCurrentGradientPosition();
        }
    }

    /**
     * Interpola entre la posición actual y la posición objetivo del gradiente.
     *
     * @param {Object} currentPosition - La posición actual del gradiente.
     * @param {Object} targetPosition - La posición objetivo del gradiente.
     * @param {number} factor - El factor de interpolación.
     *
     * @return {Object} La nueva posición interpolada del gradiente.
     */
    function interpolate(
        currentPosition: { x: number; y: number },
        targetPosition: { x: number; y: number },
        factor: number,
    ) {
        let dx = targetPosition.x - currentPosition.x;
        let dy = targetPosition.y - currentPosition.y;

        return {
            x: currentPosition.x + dx * factor,
            y: currentPosition.y + dy * factor,
        };
    }
</script>

