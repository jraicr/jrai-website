---
import { ViewTransitions } from "astro:transitions";
import "@/styles/global.css";

interface Props {
    lang: string;
    title: string;
}

const { title, lang } = Astro.props;
---

<!doctype html>
<html lang={lang}>
    <head>
        <meta charset="UTF-8" />
        <meta name="description" content="Astro description" />
        <meta name="viewport" content="width=device-width" />
        <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
        <meta name="generator" content={Astro.generator} />

        <link rel="preconnect" href="https://rsms.me/" crossorigin />

        <link
            rel="preload"
            href="https://rsms.me/inter/inter.css"
            as="style"
            onload="
            this.onload = null; this.rel = 'stylesheet'
            "
        />
        <noscript>
            <link rel="stylesheet" href="https://rsms.me/inter/inter.css" />
        </noscript>

        <title>{title}</title>
        <ViewTransitions />
    </head>
    <body>
        <slot />
    </body>
</html>
<script>
let gradientContainer = document.querySelector<HTMLElement>(".gradient-container");
let currentGradientPosition = { x: 0, y: 0 };
let targetGradientPosition = { x: 0, y: 0 };
let animationFrameId : number | null = null;
let isGradientMoving = false;

startGradientEffect();
document.addEventListener("astro:after-swap", awakeGradientEffect);

function awakeGradientEffect() {
    gradientContainer = document.querySelector(".gradient-container");
    startGradientEffect();
}

function startGradientEffect() {
    let currentScreenWidth = window.innerWidth;

    if (currentScreenWidth >= 1024) {
        onMouseMovementUpdateTargetGradientPos();
        onScrollCenterGradient();
        updateGradientPosition();
    }
}

/**
 * Actualiza la posición del gradiente a la posición del puntero del mouse.
 */
function onMouseMovementUpdateTargetGradientPos() {
    gradientContainer?.addEventListener("mousemove", (e: MouseEvent) => {
        targetGradientPosition = { x: e.pageX, y: e.pageY };
        restartAnimation();
    });
}

/**
*  Actualiza la posición objetivo del gradiente para que sea
*  el centro de la ventana visible cada vez que se hace scroll.
*/
function onScrollCenterGradient() {
    window.addEventListener("scroll", (e) => {
        targetGradientPosition = {
            x: window.scrollX + (window.innerWidth / 2) + 250,
            y: window.scrollY + window.innerHeight / 2,
        };
        restartAnimation();
    });
}

function updateGradientPosition() {
    isGradientMoving = (Math.abs(currentGradientPosition.x - targetGradientPosition.x,) > 1 || Math.abs(currentGradientPosition.y - targetGradientPosition.y,) > 1);
    
    //console.log(`Is gradient moving?: ${isGradientMoving}`, currentGradientPosition);

    if (isGradientMoving) {
        currentGradientPosition = interpolate(currentGradientPosition,
            targetGradientPosition,
            0.07,
        );
        
        if (gradientContainer) {
            gradientContainer.style.background = `radial-gradient(600px circle at ${currentGradientPosition.x}px ${currentGradientPosition.y}px, hsla(274, 100%, 35%, 0.25), transparent 80%)`;
        }
        
        animationFrameId = requestAnimationFrame(updateGradientPosition);
    
    } else if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
    }
}

function restartAnimation() {
    if (!isGradientMoving && !animationFrameId) {
        updateGradientPosition();
    }
}

function interpolate(currentPosition, targetPosition, factor) {
    let dx = targetPosition.x - currentPosition.x;
    let dy = targetPosition.y - currentPosition.y;
    
    return {
        x: currentPosition.x + dx * factor,
        y: currentPosition.y + dy * factor,
    };
}
</script>
