---
import { ViewTransitions } from "astro:transitions";
import "@/styles/global.css";
import { getLangFromUrl } from '../i18n/utils';

const lang = getLangFromUrl(Astro.url);

interface Props {
    title: string;
}

const { title } = Astro.props;
---

<!doctype html>
<html lang={lang}>
    <head>
        <meta charset="UTF-8" />
        <meta name="description" content="Astro description" />
        <meta name="viewport" content="width=device-width" />

        <!-- Fonts -->
        <!--TODO: Hostear las fuentes en el sitio -->
        <link rel="preconnect" href="https://rsms.me/" crossorigin />

        <link
            rel="preload"
            href="https://rsms.me/inter/inter.css"
            as="style"
            onload="
            this.onload = null; this.rel = 'stylesheet'
            "
        />
        <noscript>
            <link rel="stylesheet" href="https://rsms.me/inter/inter.css" />
        </noscript>

                
          <!-- Favicon -->
        <link rel="icon" href="/icons/favicon.ico">
        <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png">
        <link rel="manifest" href="/icons/site.webmanifest">

        <meta name="generator" content={Astro.generator} />

        <title>{title}</title>
        <ViewTransitions />
    </head>
    <body>
        <slot />
    </body>
</html>
<script>
let gradientContainer = document.querySelector<HTMLElement>(".gradient-container");
let currentGradientPosition = { x: 0, y: 0 };
let targetGradientPosition = { x: 0, y: 0 };
let animationFrameId : number | null = null;
let isGradientMoving = false;

startGradientEffect();

// Añade un controlador de eventos para reiniciar el efecto del gradiente después de un intercambio de Astro
document.addEventListener("astro:after-swap", awakeGradientEffect);

/**
 * Despierta el efecto del gradiente después de un intercambio de Astro.
 */
function awakeGradientEffect() {
    gradientContainer = document.querySelector(".gradient-container");
    startGradientEffect();
}

/**
 * Inicia el efecto del gradiente.
 */
function startGradientEffect() {
    let currentScreenWidth = window.innerWidth;

    if (currentScreenWidth >= 1024) {
        onMouseMovementUpdateTargetGradientPos();
        onScrollCenterGradient();
        updateCurrentGradientPosition();
    }
}

/**
 * Actualiza la posición objetivo del gradiente.
 *
 * @param {number} x - La coordenada x de la posición objetivo.
 * @param {number} y - La coordenada y de la posición objetivo.
 */
function updateTargetGradientPos(x: number, y: number) {
    targetGradientPosition.x = x;
    targetGradientPosition.y = y;
    restartAnimation();
}

/**
 * Añade un controlador de eventos para actualizar la posición objetivo del
 * gradiente a la posición del puntero del ratón.
 */
function onMouseMovementUpdateTargetGradientPos() {
    gradientContainer?.addEventListener("mousemove", (e: MouseEvent) => {
        updateTargetGradientPos(e.pageX, e.pageY);
    });
}

/**
 * Añade un controlador de eventos para actualizar la posición objetivo del gradiente al centro
 * de la ventana (con un offset hacia el contenido) visible cuando se hace scroll.
 */
function onScrollCenterGradient() {
    window.addEventListener("scroll", (e) => {
        let offsetX = 250;
        let targetX = window.scrollX + (window.innerWidth / 2) + offsetX;
        let targetY = window.scrollY + window.innerHeight / 2;

        updateTargetGradientPos(targetX, targetY);
    });
}

/**
 * Actualiza la posición actual del gradiente.
 */
function updateCurrentGradientPosition() {
    let dx = Math.abs(currentGradientPosition.x - targetGradientPosition.x);
    let dy = Math.abs(currentGradientPosition.y - targetGradientPosition.y);
    let distance = Math.sqrt(dx * dx + dy * dy);

    let lerpFactor = 0.07; // Determina velocidad de movimiento del gradiente

    isGradientMoving = (distance > 1);
    
    // console.debug(`Is gradient moving?: ${isGradientMoving}`, currentGradientPosition);

    if (isGradientMoving) {
        currentGradientPosition = interpolate(currentGradientPosition, targetGradientPosition, lerpFactor);
        
        if (gradientContainer) {
            gradientContainer.style.background = `radial-gradient(600px circle at ${currentGradientPosition.x}px ${currentGradientPosition.y}px, hsla(274, 100%, 35%, 0.25), transparent 80%)`;
        }
        
        animationFrameId = requestAnimationFrame(updateCurrentGradientPosition);

    } else if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
    }
}

/**
 * Reinicia la animación si el gradiente no se está moviendo y no hay ningún cuadro de animación solicitado.
 */
function restartAnimation() {
    if (!isGradientMoving && !animationFrameId) {
        updateCurrentGradientPosition();
    }
}

/**
 * Interpola entre la posición actual y la posición objetivo del gradiente.
 *
 * @param {Object} currentPosition - La posición actual del gradiente.
 * @param {Object} targetPosition - La posición objetivo del gradiente.
 * @param {number} factor - El factor de interpolación.
 *
 * @return {Object} La nueva posición interpolada del gradiente.
 */
function interpolate(currentPosition: { x: number; y: number; }, targetPosition: { x: number; y: number; }, factor: number) {
    let dx = targetPosition.x - currentPosition.x;
    let dy = targetPosition.y - currentPosition.y;
    
    return {
        x: currentPosition.x + dx * factor,
        y: currentPosition.y + dy * factor,
    };
}
</script>
